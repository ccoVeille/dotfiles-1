#!bash
# bashrc -- shell prompt, window title, command exit status in prompt
# (note: depends on $havecolor being set, see main bashrc)

case $TERM in
	[xkE]term*|rxvt*|cygwin|dtterm|termite)
		titlestring='\e]0;%s\a';
		wnamestring=;;
	screen*)
		titlestring='\e]0;%s\a';
		wnamestring='\ek%s\e\\';;
	*)
		titlestring=;
		wnamestring=;;
esac

settitle() { [[ $titlestring ]] && printf "$titlestring" "$*"; }

setwname() { [[ $wnamestring ]] && printf "$wnamestring" "$*"; }

# This function automatically collapses long paths to fit on screen.
# It is invoked from within $PS1 below.

_awesome_prompt() {
	local maxwidth=${COLUMNS:-$(tput cols)}

	# hostname or system name
	# + 1 (space after hostname)
	# + 2 ("…/")
	# + 1 (trailing space to avoid hitting rmargin)

	(( maxwidth -= ${#item_pfx} + ${#item_name} + ${#item_sfx} + 4 ))

	## Right side: Git branch, etc

	# Parts borrowed from git/contrib/completion/git-prompt.sh,
	# trimmed down to not cause any noticeable slowdown.

	local git= br= re=

	if ! have git; then
		git=
	elif [[ -n $GIT_DIR && -d $GIT_DIR ]]; then
		git=$GIT_DIR
	elif [[ -z $GIT_DIR && -d .git ]]; then
		git=.git
	else
		git=$(git rev-parse --git-dir 2>/dev/null)
	fi

	if [[ $git ]]; then
		if [[ -f $git/rebase-merge/interactive ]]; then
			br=$(<"$git/rebase-merge/head-name")
			re='REBASE-i'
		elif [[ -d $git/rebase-merge ]]; then
			br=$(<"$git/rebase-merge/head-name")
			re='REBASE-m'
		else
			br=$(git symbolic-ref HEAD 2>/dev/null ||
			     git describe --tags --exact-match HEAD 2>/dev/null ||
			     git rev-parse --short HEAD 2>/dev/null ||
			     echo 'unknown')

			br=${br#refs/heads/}

			if [[ -f $git/rebase-apply/rebasing ]]; then
				re='REBASE'
			elif [[ -f $git/rebase-apply/applying ]]; then
				re='AM'
			elif [[ -d $git/rebase-apply ]]; then
				re='AM/REBASE'
			elif [[ -f $git/MERGE_HEAD ]]; then
				re='MERGE'
			elif [[ -f $git/CHERRY_PICK_HEAD ]]; then
				re='CHERRY'
			elif [[ -f $git/BISECT_LOG ]]; then
				re='BISECT'
			fi
		fi

		br=${br}${re:+"|$re"}
	fi

	if [[ ! $br && -f PKGBUILD ]]; then
		local line= pkgver= pkgrel=

		while read -r line; do
			case $line in
			pkgver=*|pkgrel=*)
				declare "$line"
			esac

			if [[ $pkgver && $pkgrel ]]; then
				break
			fi
		done < PKGBUILD

		br="$pkgver-$pkgrel"
	fi

	if [[ $br ]]; then
		# branch
		# + 1 (space before branch)
		(( maxwidth -= ${#br} + 1 ))
	fi

	## Center: working directory

	local wd= wdhead= wdtail=
	local -i collapsed=0

	if [[ $fullpwd == 'y' ]]; then
		wd=$PWD
	else
		wd=${PWD/#$HOME/\~}
	fi

	if [[ $wd == '~' ]]; then
		wdhead='' wdtail=$wd
	else
		wdhead=${wd%/*}/ wdtail=${wd##*/}
	fi

	# You are not expected to understand this.
	# After I woke up, I don't understand it anymore either.

	if (( ${#wdtail} > maxwidth )); then
		wdhead=${wdhead##*/}
		collapsed=1
	elif (( ${#wdhead} + ${#wdtail} > 2 + maxwidth )); then
		if [[ ${wd:0:2} == '~/' ]]; then
			(( maxwidth -= 2 ))
		fi
		while (( ${#wdhead} + ${#wdtail} > maxwidth )); do
			if (( ! collapsed++ )); then
				wdhead=${wdhead#/}
			elif (( collapsed > 20 )); then
				break
			fi
			wdhead=${wdhead#*/}
		done
	fi

	if (( collapsed )); then
		wdhead='…/'$wdhead
		if [[ ${wd:0:2} == '~/' ]]; then
			wdhead='~/'$wdhead
		fi
	fi

	## Output

	local csi=$'m\e[' # 256-color sequences must be sent as a separate CSI,
	                  # so split the color settings into multiple CSIs

	local color_pfx=${color_pfx-$color_prompt}

	printf '\001\e[%sm\002%s' \
		"${color_pfx//|/$csi}"  "$item_pfx"  \
		""                      ""           \
		"${color_name//|/$csi}" "$item_name" \
		""                      ""           \
		"${color_pfx//|/$csi}"  "$item_sfx"  \
		""                      " "          \
		"${color_pwd//|/$csi}"  "$wdhead"    \
		"${color_cwd//|/$csi}"  "$wdtail"    \
		""                      " "          \
		"${color_vcs//|/$csi}"  "$br"        \
		""                      ""           ;
}

_is_remote() {
	[[ $SSH_TTY || $LOGIN || $REMOTEHOST ]]
}

# Set prompts (PS1, PS2, &c.)

if (( havecolor )); then
	PS1="\n"

	_hostname=${HOSTNAME%%.*}

	if (( $UID == 0 )); then
		color_name='1;37;41'
		item_name="${_hostname}"
		prompt='#'
	elif [[ $USER == "grawity" ]]; then
		if (( havecolor == 256 )); then
			color_name='1|38;5;71'
		else
			color_name='1;32'
		fi
		item_name="${_hostname}"
		prompt='$'
	else
		color_name='1;33'
		item_name="${USER}@${_hostname}"
		prompt='$'
	fi

	unset _hostname

	if (( havecolor == 256 )); then
		color_pwd='38;5;144'
		color_cwd='1'
		color_vcs='38;5;167'
		color_prompt=''
	else
		color_pwd='33'
		color_cwd='1'
		color_vcs='1;31'
		color_prompt=''
	fi

	color_pfx=''
	item_pfx=''
	item_sfx=''

	_is_remote && prompt='^'

	PS1="${PS1}\$(_awesome_prompt)\n"
	PS1="${PS1}\[\e[m\e[\${color_prompt//|/m\e[}m\]\${prompt}\[\e[m\] "

	PS2="\[\e[0;1;30m\]...\[\e[m\] "
	PS4="+\e[34m\${BASH_SOURCE:--}:\e[1m\$LINENO\e[m:\${FUNCNAME:+\e[33m\$FUNCNAME\e[m} "
else
	PS1='\n\u@\h \w\n\$ '
	PS2='... '
	PS4="+\${BASH_SOURCE:--}:\$LINENO:\$FUNCNAME "
fi

export -n PS1 PS2; export PS4

# Show status, update window title after command

_show_status() {
	local status=$?
	(( status > 0 )) &&
		printf "\e[0;33m%s\e[m\n" "(returned $status)"
}

_update_title() {
	if [[ ! $title ]]; then
		local title= t_user= t_display=
		[[ $USER != 'grawity' ]] &&
			t_user="$USER@"
		[[ $DISPLAY && ( $SSH_TTY || $DISPLAY != ':'* ) ]] &&
			t_display=" ($DISPLAY)"
		title="${t_user}${HOSTNAME} ${PWD/#$HOME/~}${t_display}"
	fi
	settitle "$title"
	if [[ ! $wname ]]; then
		local wname="${PWD/#$HOME/~}"
		[[ $wname != '~' && $wname != '/' ]] &&
			wname="${wname##*/}"
		wname="{bash:$wname}"
	fi
	setwname "$wname"
	if [[ $DISPLAY && $TERM:$COLORTERM == xterm*:gnome-terminal ]]; then
		printf '\e]7;file://%s%s\a' "$HOSTNAME" "$(urlencode -r -p "$PWD")"
	fi
}

PROMPT_COMMAND="_show_status; _update_title"
