#!/bin/bash
# vi: ft=sh

### wmiirc initialization
wmiir namespace > /dev/null || exit 1

cd ~

### Configuration

WMII_BACKGROUND="#333333"
WMII_FONT='-*-fixed-medium-r-*-*-13-*-*-*-*-*-*-*'

# UI colors (text, background, border)
WMII_NORMCOLORS="#888888 #222222 #333333"
WMII_FOCUSCOLORS="#ffffff #285577 #4c7899"
WMII_URGENTCOLORS="#ffffff #772828 #99784c"

MODKEY="Mod4"

WMII_TERM="xterm"

: ${WMII_CONFPATH:=${0%/*}}
WMII_CONFDIR="${WMII_CONFPATH%%:*}"
WMII_STARTUP="$WMII_CONFDIR/startup"

WMII_APP_OUTPUT="/dev/null"

[[ -f "$WMII_CONFDIR/config" ]] && . "$WMII_CONFDIR/config"

spawn() { cd; wmiir setsid -f "$@" < /dev/null > "$WMII_APP_OUTPUT" 2>&1; }

startup() {
	witray -s 24 & echo "++ witray[$!]"

	statusloop & echo "++ statusloop[$!]"
	statusloop_mpd & echo "++ statusloop_mpd[$!]"

	[[ -f "$WMII_CONFDIR/startup" ]] && . "$WMII_CONFDIR/startup"
}

wmiir write /ctl <<-!
	font $WMII_FONT
	fontpad 1 1 1 1
	focuscolors $WMII_FOCUSCOLORS
	normcolors $WMII_NORMCOLORS
	grabmod $MODKEY
	colmode default
	border 2
!
xsetroot -solid "$WMII_BACKGROUND" &

# /client/*/props -> instance:class:label
[[ -f "$WMII_CONFDIR/rules" ]] &&
	wmiir write /rules < "$WMII_CONFDIR/rules"

wmiir write /colrules <<-'!'
	/gimp/ -> 17+83+41
	/.*/ -> 62+38 # Golden Ratio
!

log() {
	#local tag="$$/$BASHPID"
	echo -e "wmiirc[$$]: $*"
	echo -e "\033[34m($$)\033[m $*" >> "$WMII_CONFDIR/debug.log"
}

tags() { wmiir ls /tag | sed 's|/$||; /^sel$/d'; }
this_tag() { wmiir read /tag/sel/ctl | head -n 1; }
this_tag_safe() { this_tag | sed 's/[][/\\.*&^$]/\\&/g'; }
next_tag() { tags | sed -n "1h;/^$(this_tag_safe)\$/{\${g;p};n;p;q}"; }
prev_tag() { (tags | sed -n "/^$(this_tag_safe)\$/{1q42;g;p;q};h") || (tags | sed -n "\$p"); }

this_client() { wmiir read /client/sel/ctl | head -n 1; }
client_pid() { wmiir read "/client/$1/ctl" | awk '/^pid /{print $2}'; }

program_menu() {
	wimenu -h "$WMII_CONFDIR/history" -n 20 < "$(wmiir namespace)/programs.cache"
}
action_menu() {
	for action; do
		echo "$action"
	done | wimenu -p "action:"
}
tag_menu() {
	tags | wimenu -p "${1:-view tag}:" -h "$WMII_CONFDIR/history.tags" -n 20
}

program_input() {
	local input="$(program_menu)"
	[[ "$input" ]] && eval wmiir setsid -f "$input"
}
action_input() {
	local input="$(action_menu 'quit' 'rc' 'exec wmii' 'exec' 'proglist')"
	[[ "$input" ]] && {
		set -- $input
		local action="$1"; shift
		case "$action" in
		ctl)
			wmiir xwrite /ctl "$*" ;;
		eval)
			eval "$*" ;;
		exec)
			wmiir xwrite /ctl "exec $*" ;;
		quit)
			wmiir xwrite /event "Suicide"
			wmiir xwrite /ctl "quit"
			;;
		proglist)
			program_cache &
			;;
		rc)
			restart_rc ;;
		esac
	}
}

display_client_info() {
	local client="$1"
	local pid="$(client_pid "$client")"
	local winst wclass wlabel
	IFS=':' read winst wclass wlabel < <( wmiir read "/client/$client/props" )

	{
		echo -e "Instance:\t$winst"
		echo -e "Class:\t$wclass"
		echo -e "Label:\t$wlabel"
		if [[ "$pid" ]]
			then echo -e "Process:\t($pid) $(ps -o 'cmd=' $pid)"
			else echo -e "Process:\tunknown"
		fi
		echo "Control:"
		wmiir read "/client/$client/ctl" | sed 's/^/\t/'
		echo "Properties:"
		wmiir read "/client/$client/props" | sed 's/^/\t/'
	} | wmiir setsid -f wihack -transient "$client" \
		zenity --text-info --title="Client $client"
}

htmlescape() { sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g; s/"/\&quot;/g'; }

event() {
	local evtype="$1"; shift
	case "$evtype" in
	Start)
		log "received start event from another wmiirc"
		return 1
		;;
	Suicide)
		log "received shutdown request"
		return 1
		;;
	Respawn)
		restart_rc
		;;

	CreateTag)
		{	echo colors "$WMII_NORMCOLORS"
			echo label "$*"
		} | wmiir create "/lbar/$*"
		;;
	DestroyTag)
		wmiir remove "/lbar/$*"
		;;
	FocusTag)
		{	echo colors "$WMII_FOCUSCOLORS"
			echo label "$*"
		} | wmiir write "/lbar/$*"
		;;
	UnfocusTag)
		{	echo colors "$WMII_NORMCOLORS"
			echo label "$*"
		} | wmiir write "/lbar/$*"
		;;
	UrgentTag)
		shift
		{	echo colors "$WMII_URGENTCOLORS"
			echo label "$*"
		} | wmiir write "/lbar/$*"
		;;
	NotUrgentTag)
		shift
		{	if [ "$*" = "$(this_tag)" ]; then
				echo colors "$WMII_FOCUSCOLORS"
			else
				echo colors "$WMII_NORMCOLORS"
			fi
			echo label "$*"
		} | wmiir write "/lbar/$*"
		;;

	LeftBarClick)
		local button="$1"; shift
		case "$button" in
		1) wmiir xwrite /ctl "view $*";;
		2) ;; #menu
		3) ;; #close?
		4) wmiir xwrite /ctl "view $(prev_tag)";;
		5) wmiir xwrite /ctl "view $(next_tag)";;
		esac
		;;
	LeftBarDND)
		shift
		wmiir xwrite /ctl "view $*"
		;;

	RightBarClick)
		local button="$1"; shift
		case "$*" in
		"mpc")
			case "$button" in
			1)
				if mpc >& /dev/null; then
					mpc toggle
				else
					spawn mpd
				fi ;;
			2) mpc prev ;;
			3) mpc next ;;
			4) mpc volume "+5" ;;
			5) mpc volume "-5" ;;
			esac > /dev/null ;;
		"status")
			case "$button" in
			1) spawn slock ;;
			esac ;;
		esac
		;;
	
	ClientMouseDown)
		local client="$1" button="$2" cmd=""
		case "$button" in
		3)
			cmd="$(wmii9menu -i "info" -- \
				"close" \
				"kill" \
				"fullscreen" \
				"info" \
				"retag" \
			)"
			case "$cmd" in
				close)
					wmiir xwrite "/client/$client/ctl" "kill"
					;;
				kill)
					local wlabel="$(wmiir read "/client/$client/label" | htmlescape)"
					local pid="$(client_pid "$client")"
					if [[ "$pid" ]]
						then local process="<b>$(ps -o 'cmd=' $pid | htmlescape)</b> (PID $pid)"
						else local process="<i>unknown</i>"
					fi
					local msg="Do you really want to disconnect the process that this window belongs to?\n\nWindow:\t${wlabel}\nProcess:\t${process}"
					{
						wihack -transient "$client" \
						zenity --question --title="Disconnect process" \
						--text="$msg" \
						--ok-label="Cancel" --cancel-label="Disconnect" \
						|| wmiir xwrite "/client/$client/ctl" "slay"
					} &
					;;
				fullscreen)
					wmiir xwrite "/client/$client/ctl" "fullscreen on"
					;;
				info)
					display_client_info "$client"
					;;
				retag)
					local wlabel="$(wmiir read "/client/$client/label")"
					local wtags="$(wmiir read "/client/$client/tags")"
					local input="$(zenity --entry --title="Retag" \
						--text="Enter new tags for window:\n$wlabel" \
						--entry-text="$wtags")"
					[ "$input" ] && wmiir xwrite "/client/$client/tags" "${input// /+}"
					;;
			esac
			;;
		esac
		;;

	ClientClick)
		local client="$1" button="$2"
		case "$button" in
		2) wmiir xwrite "/client/$client/ctl" "kill";;
		esac
		;;

	Unresponsive)
		local client="$1"
		local msg="$(printf "The following client is not responding:\n\n%s\n\nWhat would you like to do?" "$(wmiir read /client/"$client"/label)")"

		if ! wihack -transient "$client" zenity --question --text="$msg" \
			--ok-label="Wait" --cancel-label="Kill"; then
			wmiir xwrite "/client/$client/ctl" "slay"
		fi &
		;;

	Key)
		event_Key "$@"
		;;

	# Debugging through 'wmiir write /event'
	Debug)
		{
			printf "\033[34m($$)\033[m Debug: \033[1m%s\033[m\n" "$*"
			eval set -- "$*"
			case "$1" in
			c|ctl)
				shift; wmiir xwrite /ctl "$@";;
			e|eval)
				shift; eval "$@";;
			ev|event)
				shift; wmiir xwrite /event "$@";;
			.|poke)
				echo -e "\e[1;35mI am $$ (pgroup $MY_PGROUP, sid $MY_SID)\e[m"
				;;
			p|ps)
				wmiir setsid ps -o pid,ppid,comm,command --forest -$MY_PGROUP;;
			pstree)
				wmiir setsid pstree -Up $$;;
			r|read)
				wmiir read "$2";;
			re|restart)
				if [ "$2" = "rc" ]; then
					wmiir xwrite /ctl "spawn $0"
				elif [ "$2" = "wmii" ]; then
					wmiir xwrite /ctl "exec wmii"
				fi
				;;
			w|write)
				shift; wmiir xwrite "$@";;
			addrule)
				shift; { wmiir read /rules; echo "$*"; } | wmiir write /rules;;
			*)
				echo -e "\e[1;33mUnknown debug command $1\e[m";;
			esac
		} >> "$WMII_CONFDIR/debug.log" 2>&1
		;;
	esac
	return 0
}

#declare -F | sed -n -e "s/^declare -f //; /^key_/ {s/^key/${MODKEY}/; y/_/-/; p}" | wmiir write /keys

event_Key() {
	local key="$1" mod=""
	if [[ "$key" == *-* ]]; then
		mod="${key%-*}"
		key="${key##*-}"
	fi

	case "$mod" in

	$MODKEY)
		case "$key" in
		h) wmiir xwrite /tag/sel/ctl "select left";;
		j) wmiir xwrite /tag/sel/ctl "select down";;
		k) wmiir xwrite /tag/sel/ctl "select up";;
		l) wmiir xwrite /tag/sel/ctl "select right";;
		space) wmiir xwrite /tag/sel/ctl "select toggle";;
		[0-9]) wmiir xwrite /ctl "view $key";;
		d) wmiir xwrite /tag/sel/ctl "colmode sel default-max";;
		s) wmiir xwrite /tag/sel/ctl "colmode sel stack-max";;
		m) wmiir xwrite /tag/sel/ctl "colmode sel stack+max";;

		f) wmiir xwrite /client/sel/ctl "fullscreen toggle";;
		q) wmiir xwrite /client/sel/ctl "kill" ;;

		Return|KP_Enter) spawn "$WMII_TERM" ;;

		p) program_input ;;
		Menu) action_input ;;
		a) action_input ;;

		t)
			local input="$(tag_menu)"
			[[ "$input" ]] && wmiir xwrite "/ctl" "view $input"
			;;
		esac;;
	
	$MODKEY-Shift)
		case "$key" in
		h) wmiir xwrite /tag/sel/ctl "send sel left";;
		j) wmiir xwrite /tag/sel/ctl "send sel down";;
		k) wmiir xwrite /tag/sel/ctl "send sel up";;
		l) wmiir xwrite /tag/sel/ctl "send sel right";;
		space) wmiir xwrite /tag/sel/ctl "send sel toggle";;
		[0-9]) wmiir xwrite /client/sel/tags "$key";;

		d) wmiir xwrite /tag/sel/ctl "colmode sel default+max";;

		t)
			local client="$(this_client)"
			local input="$(tag_menu 'retag')"
			[[ "$input" ]] && wmiir xwrite "/client/$client/tags" "$input"
			;;
		esac;;

	$MODKEY-Control)
		case "$key" in
		j) wmiir xwrite /tag/sel/ctl "select down stack";;
		k) wmiir xwrite /tag/sel/ctl "select up stack";;
		esac;;

	"")
		case "$key" in
		Menu) program_input ;;
		esac;;

	Control)
		case "$key" in
		Menu) program_cache; program_input ;;
		esac;;

	esac
}

program_cache() {
	local IFS=:
	wmiir proglist -- $PATH > "$(wmiir ns)/programs.cache"
}

## Loops for statusbar updating
statusloop() {
	printf "wistatus" > /proc/self/comm
	local path

	while true; do
		path="/rbar/zy_load"
		status_load | { wmiir write "$path" || wmiir create "$path"; }

		path="/rbar/zz_status"
		status_clock | { wmiir write "$path" || wmiir create "$path"; }

		sleep 1
	done
}
statusloop_mpd() {
	printf "wistatus.mpd" > /proc/self/comm
	local path="/rbar/mpc"

	status_mpd | wmiir create /rbar/mpc
	while true; do
		mpc idle >& /dev/null || sleep 5
		status_mpd | { wmiir write "$path" || wmiir create "$path"; }
	done
}

status_load() {
	local load1 load2 load3 rest
	read load1 load2 load3 rest < /proc/loadavg
	echo colors "$WMII_NORMCOLORS"
	echo label "$load1 $load2 $load3"
}
status_clock() {
	echo colors "$WMII_NORMCOLORS"
	date +'label %a, %b %d %H:%M'
}
status_mpd() {
	local FG_PLAYING='#bbbbbb'
	local FG_PAUSED="${WMII_NORMCOLORS%% *}"
	local FG_STOPPED='#666666'
	local BG="${WMII_NORMCOLORS#* }"
	{
		if ! mpc > /dev/null; then
			echo colors "$FG_STOPPED $BG"
			echo label "(mpd not running)"
			return $?
		elif mpc | grep -qs '^\[playing\]'; then
			echo colors "$FG_PLAYING $BG"
			echo label "$(mpc current)"
		elif mpc | grep -qs '^\[paused\]'; then
			echo colors "$FG_PAUSED $BG"
			echo label "(paused) $(mpc current)"
		else
			echo colors "$FG_STOPPED $BG"
			echo label "(stopped)"
		fi
	} 2> /dev/null
}

suicide() {
	log "\e[1;31mkilling self\e[m (pgroup=$MY_PGROUP)"
	trap - TERM; kill 0
}
restart_rc() {
	wmiir xwrite /ctl "spawn $0"
}
restart_wmii() {
	wmiir xwrite /ctl "exec wmii"
}

### Start wmiirc
MY_PGROUP="$(ps -o 'pgrp=' $$ | tr -d ' ')"
MY_SID="$(ps -o 'sid=' $$ | tr -d ' ')"

trap "suicide" INT QUIT TERM EXIT

wmiir write /event <<< "Start $0"

# Bind keys
for key in \
	$MODKEY-{h,j,k,l,space,a,d,f,m,p,q,s,t} \
	$MODKEY-{0..9} \
	$MODKEY-Return $MODKEY-KP_Enter \
	$MODKEY-Shift-{h,j,k,l,space,d} \
	$MODKEY-Shift-{0..9} \
	$MODKEY-Control-{j,k} \
	Menu \
	Control-Menu \
; do echo "$key"; done | wmiir write /keys

# Set up tags
wmiir ls -p /lbar | xargs wmiir rm
current="$(this_tag)"
tags | while read tag; do
	if [ "$tag" = "$current" ]; then
		echo colors "${WMII_FOCUSCOLORS[*]}"
		echo label "$tag"
	else
		echo colors "${WMII_NORMCOLORS[*]}"
		echo label "$tag"
	fi | wmiir create "/lbar/$tag"
done

# Set up rbar
wmiir ls -p /rbar | xargs wmiir rm
wmiir create '/rbar/!' < /dev/null

program_cache &
startup

log "\e[1;32mstarted\e[m ($0) \e[1mpgroup=$MY_PGROUP\e[m sid=$MY_SID"

# Event loop
while read event; do
	event $event || suicide
done < <(exec wmiir read /event)

# Cleanup
log "eventloop finished"
suicide
